import wpilib
import commands2
import wpimath.geometry
import wpimath.kinematics
import math
from photonlibpy.photonCamera import PhotonCamera
from pathplannerlib.auto import AutoBuilder
from pathplannerlib.config import RobotConfig, PIDConstants
from pathplannerlib.controller import PPHolonomicDriveController

# Constants
CAMERA_HEIGHT_METERS = 0.5
TARGET_HEIGHT_METERS = 2.5
CAMERA_PITCH_RADIANS = math.radians(30.0)
SHOOTER_PITCH_RADIANS = math.radians(45.0)
SHOOTER_HEIGHT_METERS = 0.5
GRAVITY = 9.81
YAW_TOLERANCE = 3.0


class Shooter(commands2.Subsystem):
    def __init__(self):
        super().__init__()
        # TODO: Initialize shooter motors here (e.g. CANSparkMax, TalonFX)

    def set_velocity(self, velocity: float):
        # TODO: Set motor closed-loop velocity
        pass

    def stop(self):
        # TODO: Stop motors
        pass


class Climber(commands2.Subsystem):
    def __init__(self):
        super().__init__()
        # TODO: Initialize climber motors/solenoids here

    def deploy_hooks(self):
        # TODO: Actuate solenoids or move arm to deploy hooks
        pass

    def climb(self):
        # TODO: Run winch or arm motors to lift robot
        pass


class MyRobot(commands2.TimedCommandRobot):
    def robotInit(self):
        """
        This function is called upon program startup and
        should be used for any initialization code.
        """
        # --- PhotonVision Initialization ---
        # Replace 'cameraName' with the name set in the PhotonVision UI
        self.camera = PhotonCamera("Arducam_OV9281_USB_Camera")

        # --- Subsystems ---
        self.shooter = Shooter()
        self.climber = Climber()

        # --- PathPlanner Initialization ---
        # Define callbacks for the AutoBuilder.
        # In a real robot, these would interact with your DriveSubsystem.

        # Dummy pose for example purposes
        self.pose = wpimath.geometry.Pose2d()

        def get_pose():
            return self.pose

        def reset_pose(new_pose):
            self.pose = new_pose

        def get_robot_relative_speeds():
            return wpimath.kinematics.ChassisSpeeds()

        def drive_robot_relative(speeds):
            # Logic to drive the robot based on speeds
            pass

        self.auto_chooser = None

        try:
            # Load robot configuration from the deploy directory (generated by PathPlanner GUI)
            config = RobotConfig.fromGUISettings()

            # Configure AutoBuilder for a Holonomic Drivetrain (Swerve/Mecanum)
            AutoBuilder.configure(
                get_pose,
                reset_pose,
                get_robot_relative_speeds,
                drive_robot_relative,
                PPHolonomicDriveController(
                    PIDConstants(5.0, 0.0, 0.0),  # Translation PID constants
                    PIDConstants(5.0, 0.0, 0.0),  # Rotation PID constants
                ),
                config,
                self.shouldFlipPath,  # Supplier to determine if path should be flipped
            )

            # Create the Auto Chooser and send to SmartDashboard
            self.auto_chooser = AutoBuilder.buildAutoChooser()
            wpilib.SmartDashboard.putData("Auto Mode", self.auto_chooser)
        except Exception as e:
            # Handle missing config or other errors gracefully
            wpilib.reportError(f"PathPlanner configuration failed: {e}")

    def shouldFlipPath(self):
        # Flip the path if we are on the Red Alliance
        return wpilib.DriverStation.getAlliance() == wpilib.DriverStation.Alliance.kRed

    def robotPeriodic(self):
        # Runs the Scheduler. This is required for Commands to run.
        super().robotPeriodic()

        ready, velocity = self.get_shooting_solution()

        if self.isEnabled():
            if ready:
                self.shooter.set_velocity(velocity)
            else:
                self.shooter.stop()

        self.update_dashboard(ready, velocity)

    def update_dashboard(self, ready, velocity):
        """Updates SmartDashboard with subsystem data."""
        wpilib.SmartDashboard.putBoolean("Shooter/Ready", ready)
        wpilib.SmartDashboard.putNumber("Shooter/TargetVelocity", velocity)

    def get_shooting_solution(self):
        """
        Determines if the robot is oriented and in range to make a basket.
        Returns a tuple (is_ready, target_velocity).
        """
        result = self.camera.getLatestResult()
        if not result.hasTargets():
            return False, 0.0

        target = result.getBestTarget()

        # 1. Check Orientation (Yaw)
        # Assume 0 yaw is centered on target. Tolerance in degrees.
        if abs(target.getYaw()) > YAW_TOLERANCE:
            return False, 0.0

        # 2. Check Range
        # Calculate distance manually: d = (h_target - h_camera) / tan(camera_pitch + target_pitch)
        distance = (TARGET_HEIGHT_METERS - CAMERA_HEIGHT_METERS) / math.tan(
            CAMERA_PITCH_RADIANS + math.radians(target.getPitch())
        )

        # Example range logic (meters)
        if distance < 1.5 or distance > 6.0:
            return False, 0.0

        # 3. Calculate Velocity (Physics-based)
        # Height difference between target and shooter
        h = TARGET_HEIGHT_METERS - SHOOTER_HEIGHT_METERS

        # Physics formula: v = (d / cos(theta)) * sqrt(g / (2 * (d * tan(theta) - h)))
        # Ensure the term under sqrt is positive (shot is possible)
        if distance * math.tan(SHOOTER_PITCH_RADIANS) <= h:
            return False, 0.0

        velocity = (distance / math.cos(SHOOTER_PITCH_RADIANS)) * math.sqrt(
            GRAVITY / (2 * (distance * math.tan(SHOOTER_PITCH_RADIANS) - h))
        )

        return True, velocity

    def autonomousInit(self):
        if self.auto_chooser is None:
            return

        self.autonomous_command = self.auto_chooser.getSelected()
        if self.autonomous_command:
            self.autonomous_command.schedule()

    def teleopInit(self):
        if hasattr(self, "autonomous_command") and self.autonomous_command:
            self.autonomous_command.cancel()


if __name__ == "__main__":
    wpilib.run(MyRobot)
